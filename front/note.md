서버 이야기는 왜하는가?

웹사이트 잘 만들었는데 어쩌라고?
--> 다른사람이 들어가서 당신의 사이트를 보려면 당신의 사이트는 그어떤 컴퓨터에 저장되어 있어서 상대방이
인터넷으로 들어가서 봐야한다.

내가 만든 웹사이트를 저장하고 다른사람이 볼 수 있게 하는 컴퓨터 = 서버
그리고 내가 만든 사이트를 가진 컴퓨터는 고유의 주소가 있다. (모든 컴퓨터는 고유의 주소가 있다) - ip 주소

원래는 네이버든 구글이든 모든 웹사이트는
이런식으로 입력해야만 들어가진다. 예) 61.97.130.157

이런 숫자로만 이루어진 ip 주소를 사람이 알아볼 수 있는 도메인 주소로 변환해주는 과정이 있다.
이를 DNS(Domain Name Service)라고 한다.

61.97.130.157 --> google.com

만약에 온라인 게임같이 한번에 불러와야하는 데이터가 많은 경우는?
--> 이용자 컴퓨터에 사전에 필요한 파일과 프로그램을 미리 설치해둔다.

<!-- Node -->
node.js는 웹서비스의 서버 역할을 담당하는데,
node package manager 즉, NPM 이라는 패키지 모음을 제공합니다.
이 패키지 모음에는 747269개의 컨텐츠 개수에 맞는 하위 페이지 자동생성 기능,
서버 작업 시 오류 메세지 설정, 리액트 등의 프론트엔드 기능구현 툴(리액트는 node.js 패키지의 일부입니다.)
그리고 데이터 전송을 담당하는 API와 인터넷 데이터전송 및 접속과 관련된 HTTP 규격 사용 기능제공과 같은
서버와 클라이언트의 통신을 돕는 기능을 제공합니다.

서버안에 데이터베이스를 연결을 하려면 SQL 데이터 베이스와의 연결을 돕습니다.

### node.js의 특성
1. 비동기처리 기능을 지원한다.
   - 비동기처리 기능 : 특정 작업의 결과를 기다리지 않고 다른 작업이 동시에 이루어지는 기능

문제점 : 특정 작업이 완료된 이후에 움직여야하는 중요한 작업이 있는데 전부 무시하고 움직여 버린다.
ex) 데이터가 들어오지 않았음에도 먼저 출력하기 때문에 문제가 있는 것처럼 보인다.

선행작업이 완료되어야하는 후속 작업을 진행하는 부분을 명확히 파악하고 별도로 처리해줘야한다.

이 문제를 해결 할 수 있는 콜백함수가 있다.
callback, promise, async, await 등이 있다.

전부 특정 작업이 완료된 후 후속작업을 이루게 해주게 특수조건을 거는 기능들이다.

<!--  -->

모든 요청을 accept 할 수는 없다. 일반적인 웹 서버는 url 경로에 따라 다른 컨텐츠를 보여주게 되어있다.
url 경로에 따라 다른 컨텐츠로 보여주는 기능을 라우팅이라 한다.
url의 경로를 읽어서 다른 응답을 웹서비스 이용자가 볼 수 있도록 코드를 수정하겠습니다.

<!--  -->

웹 서버를 만들었고, 웹서버 내부 세부 주소에 해당하는 콘텐츠 표시법까지 배웠습니다.

리팩토링 : 동적 결과를 바꾸지 않으면서 

<!-- 2024-04-18 -->
node.js 기본으로는 웹서버를 만들 때 기능이 좀 부족하다.
미들웨어 기능이 없어서 그렇다.

미들웨어란 요청과 응답사이 데이터 혹은 특정 작업을 할 수 있도록 중간에서 매개역할을 하는 기능을 의미한다.

예를들어, 유저와 서비스업체간의 요청과 응답 처리 시, 요청이 제대로 안되면
xyz 작업을 해라, 오류 메세지를 띄워라 등 중간에서 작업하는 기능이 필수적임을 이해하면 된다.

그리고 우리가 작업한 프론트엔드 파일들 읽어들인 후에 화면에 출력해야합니다.
그런 프론트엔드 화면 구현을 돕는 기능도 모자랍니다.
그래서 나오는게 express 프레임워크입니다.

node.js 는 무료로 사용할 수 있는 외부 라이브러리(npm, node package manager)가 많습니다.

npm install express 라는 뜻은
패키지 저장소에 있는 express를 설치하라는 뜻입니다.

express를 쓰는 또다른 이유는 데이터를 전송하는 api가 내장된다.

api의 4대요소 = crud
create = 글 생성 post
read = 기존 글 읽기 get
update = 기존 글 바꾸기 set
delete = 기존 글 삭제 delete

<!--  -->
npm init -y 
node.js package 초기화 (package.json 파일 만들기)
- 웹 서비스 구축을 선언한다.

프로그램에 대한 정보를 남길 수 있고, 전체 웹서비스 시작 자바스크립트 코드가 무엇인지도 알린다.

<!--  -->
자바스크립트 비동기 처리방법
콜백:
비동기 코드를 순서대로 실행하는 부분을 처리하는 방안
실행 가능한 함수를 인풋으로 전달해서 특정 상황 발생 시 후속작업이 호출되게 하는 원리를 가지고 있다.

promise, async, await

<!-- 240419 -->
AXIOS란? (feat. Fetch API)
AXIOS는 Promise API를 활용하는 HTTP 비동기 통신 라이브러리입니다.
동기호 ㅏ처리 프라미스 기능을 활용하는 데이터전송 api 기능지원
-> 동기화 에러처리 기능이 있는 데이터 전송툴이 axios 입니다.

status 숫자에 대해 알리고자 합니다.
404 코드는 존재하지 않는다는 뜻입니다.
200이면 정상, 400이면 클라이언트 에러, 500이면 서버 에러입니다.

숫자코드를 가지고 내 서버가 어디에 문제가 있는지 알 수 있습니다.

<!-- day31 -> axios -> promise3.js -->
서버상의 배열 json 데이터의 파싱을 해보았습니다.
배열 json 데이터는 value 값 안에 json 데이터 셋이 복합적으로 들어있어서
정확한 데이터 해석(파싱)을 통해 원하는 결과를 부르는데 주의해야합니다.

promise에서 이행과 실패 두가지를 resolve, reject 두가지 인수로 처리하였습니다.
근데 사용자가 기다리는 상태일 경우,
promise 객체의 실행완료까지 사용자가 기다리는 상태일 수 있으니
대기 상태까지 알려주는 기능을 제공하는 것이
async, await 입니다.

aysnc 기반의 코드에서 나타나야 할 필수요소는
async로 작업요청을 했다면 작업완료 까지 기다리는 await 명령어가 필수적이다.
그래서 보통 실행하는 async, 기다리는 await, 성공 시 나타나는 try 실패시 나타나는 catch 요소가 들어간다.

nodemon이란 패키지는 일일이 서버를 꺼서 변경사항을 반영하지 않고
파일 내용이 바뀌면 바로 변경사항을 적용해주는 라이브러리이다.

npm install이라고 하면 package.json에 기록된 모든 라이브러리가 설치됩니다.
그렇게 해서 express 와 nodemon 패키지를 설치해주세요.

외부링크를 클릭했을 때
can not get /recommend 가 뜬 이유
html 문서가 api 경로를 접근하지 않고 html 파일로 들어가려고 해서
node.js의 서버는 지정도니 파일이 있는 경로 자체가 아닌 파일은
직접적으로 인식하지 못했기 때문이다.

그리고 아까 폼태그도 문제가 있었던건, 서버가 없는 프론트 시절
form 태그의 method = post 데이터 전송방식을 태그에 지정하지 않았기 때문

<!-- 20230422 -->
컨텐츠에 따라서 페이지 개수와 화면에 표시되는 컨텐츠를 위한 html 요소가 생성/삭제되어야 한다.

인터넷 기업의 비즈니스모델(BM)은 동적인 컨텐츠를 요구하는데 HTML 정적요소라면 무슨 문제가 발생하는가?
- 데이터의 개수에 맞게 페이지를 코딩해야한다.
- 데이터가 저장된 변수의 내용을 동적으로 반영하는 것은 일반적인 HMTL에서는 불가능하다.

동적 컨텐츠 처리를 하기 위한 장치가 필요한데 그게 node.js & react 입니다.

동적 컨텐츠 처리는 크게 2가지가 있습니다.
- 데이터가 들어있는 변수를 페이지 컨텐츠에 표현하는 부분
- 컨텐츠에 맞는 추가적인 웹주소(경로)를 만드는 부분이 필요하다.

promise는 함수의 단위마다 성공과 실패조건을 명시하고 요청과 응답사이의 미들웨어 기능이 없다.
그리고 이행, 실패, 대기 3가지 조건은 크게 이행과 실패로만 구분되는 특성이 있는것을 볼 수 있다.
이를 보완하려는게 async, await 이다. 서버와 클라이언트 사이마다 중간에서
특정 작업이 필요한 경우가 있는데 이를 미들웨어라고 한다.
미들웨어에 대한 작업을 가능하게 해준다.

promise와 반대되는 개념이 아니다.
실행하려는 promise 객체 앞에 async를 붙이고 await을 붙여서 객체의 실행을 기다린다.
await은 그래서 async 키워드를 사용한 함수안에서만 사용 할 수 있다.

<!--  -->
1. 정적컨텐츠에서의 풀스택
2. 동적 컨텐츠의 표현

기존의 프론트엔드에서 웹서버상으로 경로가 지정되고 데이터 기반으로 페이지가 바뀐다면 html 지금 파일은 무엇이 달라져야 하는가?
1. a 태그의 restaurants.html 과 같은 부분은 오류가 날 것이다.
   (파일이 웹서버 경로로 이동해 버려서 restaurants.html 파일로 직접 접근 할 수 없다)
2. json 파일의 정보가 들어오는 경우 프론트 페이지 상에서 구현해야한다.
   (html 파일은 정적인 속성을 가지고 있다. 기존의 html을 보완하는 프레임워크가 필요한 실정이다)

데이터가 바뀔때마다 데이터를 받는 html을 일일이 다시 코딩 할 수 없다.
이번 예제는 ejs라는 프레임워크를 소개하여 본 컨텐츠를 표현할 계획이다.

1. 웹세버에 페이지 올릴 때 html 태그 처리방식
2. html 에서 폼태그 내부 데이터 전송방식이라고 get 방식 post 방식이라 떠들었는데 그게 왜 필요했는지 확인
3. 왜 html만으로 부족했는지 확인

### ejs특징
1. html의 컴포넌트화 가능
2. 자바스크립트 변수 받을 수 있음
3. 자바스크립트 코드가 바로 사용될 수 있음

데이터 관련 작업 2파트
1. json 데이터에 사용자 폼태그 작성 데이터 저장하기 (recommend.html)
2. 저장한 데이터를 restaurant.html 화면에 표시하기
2-1. app.js 안에서 데이터를 받아와야한다.
2-2. restaurants.ejs 안에서 받아온 데이터를 자바스크립트 변수로 읽어서 화면에 표시

다이나믹 라우트 생성 (컨텐츠 데이터수에 맞는 url 생성)
http://localhost:3000/restaurants/r1

<!-- 20240423 -->
동적경로 & 오름차순, 내림차순 컨텐츠 정렬을 구현하기
1. 하위페이지 생성


코드 리팩토링, 즉 데이터 처리관련 코드를 별도의 폴더에 두어 화면 구현관련 코드, 데이터 json 파일 처리 관련코드 두 파트로 나누는 작업을 하려고합니다.

백엔드 관련 함수가 fm으로 가면 (요청, 응답) = (req, res) 외에
(에러, 요청, 응답, 다음작업) = (error, req, res, next) 총 4가지 경우의 값을 입력받는다.
function(error, req, res, next)
이 다음작업의 의미는 요청과 응답사이의 중간작업을 의미하며 이를 미들웨어라 한다.
그래서 오류, 요청, 응답, 미들웨어 처리 총 4가지의 작업을 입력받게 되는 것이다.

다음엔 코드 최적화를 해봅시다. 지금부터 apps.js를 30초간 보고 무엇을 개선 할 수 있을지 생각해보세요.

폼태그를 만들고 데이터가 들어올 수 있게 method 