<!-- 20240501 -->
데이터베이스를 연결하려는 이유

프론트엔드에 데이터베이스가 직접 보이면 노출 될 수 있습니다.
자바스크립트의 경우 실행되는 코드를 수정 할 수 있어서
해킹에 취약해질 수 있습니다.

보안처리된(숨김처리) 별도의 파일에 로그인 정보를 담아
로그인 시 타인이 볼 수 없게 조치 할 예정이며 이를 위한 node.js 패키지도 실습합니다. (dotenv)

1. 로그인 보안확립 (dotenv)
2. api 활용한 게시판
3. mysql 연결 + sql 쿼리가 살아있는 누적 데이터베이스 구축
--> 기업은 누적 고객 데이터베이스를 소유하길 원한다.
--> 단순 단발성 입력글이 아닌 누적데이터가 있다면
--> 고객 추천 알고리즘 개발가능 (유튜브)

npm install ejs express nodemon dotenv
sql 사이드에서 작업 준비를 해야합니다.
--> 스키마 & 테이블을 만들어야합니다.

테이블이 authors & post 두 개가 있습니다.
게시글 작성자 테이블과 게시글 테이블이 있습니다.

<!--  -->
서버 구축, 페이지 로딩, 에러처리에 대한 사전 작업이 완료되었으니 sql 로그인 정보를 입력하여 mysql과 통신을 해보겠습니다.

node.js 와 mysql을 연결하기 위해서 패키지가 하나 더 필요합니다.
mysql2를 다운받아주세요.

지난번에 router 기억하시나요?
이넡넷 라우터 기기 이야기 하면서
외부페이지 경로를 app.js
메인으로 담기엔 파일이 너무 길어지니까 router 라는 기능을 이용해서
app.js에 담을 경로 내용을 외부파일로 뺄 수 있다고 해서 실습했던 내용입니다.
routes라는 폴더를 만들어주세요, 그 안에 blog.js 파일을 만들어주세요.

메인인 app.js에서는 아무도 오류가 없었다.
오류의 유형
1. 폴더 이름 data --> date
2. 로그인 정보 강사의 샘플코드의 패스워드 미변경
3. 강사 마음대로 포트번호 변경
4. /, s 붙고 빠지는 등의 사소한 오타

현재 단계에서 사용자 계정이 안보이는 이유
--> 프론트엔드에서 데이터를 받고 표현하는 데이터 변수와 자바스크립트 코딩이 없다.

dotenv 사용 시 주의사항
git 올리 실 때 올리지 않습니다.
그룹 코딩 할 때는 자바스크립트 했다가 나중에 .env 조용히 만들어서
node.js 는 폴더와 파일의 위치가 정해져 있는 경우가 많다.
예를 들어, .env 파일은 반드시 메인 폴더에 있어야 하며
routes 폴더나 views 폴더 등 기본은 정해져 있다.
특히 .env 파일의 위치가 맞지 않으면 그냥 로그인이 안된다고만 하고 디버그가 어려우니
.env 보안설정은 맨 나중에 하는 것을 권장한다.

<!-- 20240502 -->
웹서비스 프로그래밍 실습2
웹서비스에 mysql 데이터베이스를 연결합니다.
그래서 데이터 베이스 기반으로 서비스 내용을 출력합니다.

--> mySQL 데이터베이스 로그인 (dotenv)
--> 사용자 정보를 등록
--> 등록된 사용자만 글을 쓸 수 있게 처리함

1. 우리는 어떤 데이터를 sql에 포스팅 해야 하는가
--> 무슨데이터를 추가할지 확인하기
제목, 요약, 본문, 작성자ID
전송 버튼을 누르는 순간 sql 데이터베이스로 게시글이 전달되어야 한다.

2. 추가한 데이터를 화면에 표시해야한다.
--> 컨텐츠 수만큼 html, css가 적용되어 화면표시
--> 세부페이지는 역시 데이터의 수만큼 생성
(다이나믹컨텐츠 + 다이나믹라우트(경로))

3. 글의 생성, 조회 + 삭제, 수정 (CRUD API 기능)
CREATE READ UPDATE DELETE

3가지를 모두 하면 컨텐츠 완성

# 테이블 안에 데이터를 집어넣는 쿼리문입니다.
# 지금 쿼리문은 테이블 안의 컬럼 이름을 담았습니다.
# 테이블 안에 컬럼 이름을 특정하는 경우, 특정된 컬럼에만 데이터를 담을 수 있습니다.
# post 테이블 안에 시간과 primary key 값은 작업하지 않습니다.
`insert into posts (title, summary, body, author_id) values (?)`, [data, ]

sql 데이터베이스 연결 시 주의 할 점은 비동기의 동기화 작업을 해야한다는 것이다.
페이지 로딩이 sql 데이터 조회보다 빨라서 sql 데이터가 정상임에도 데이터를 가져오지 않고
페이지를 로딩하면 마치 아무데이터가 없는것처럼 나오는 문제가 있을 수 있다.
--> 그래서  async & await 추가

금번 예제는 다이나믹 라우트 사용으로 인해 app.js 에 코딩이 분산되었습니다.
그 결과, 메인 실행 스크립트인 app.js 는 뷰 엔진 설정, 필수 라이브러리 호출
포트번호 설정과 같은 기능만 남아 코드의 기능에 따라 파일이 분산 될 수 있게 잘 처리되었습니다.
(express의 Route 함수 기억하시죠?)

데이터베이스 연결할거면 무조건 async await 을 씁니다.
디버그가 어렵스빈다.

데이터가 들어오지 않는다는 에러메세지가 나오는데요,
데이터가 안들어오는게 내가 쿼리를 잘못한건지
변수가 잡히지 않은건지
프론트엔드에서 못받은건지
정말 비동기처리 문제라서 그런건지 모릅니다.
--> 비동기 처리의 동기화라던지, 로그인 사전확인 등, 예측가능한 오류의 경우의 수를 줄여나가야 합니다.

컨텐츠의 개수만큼 세부 url을 만들도록 합니다.

게시판 글의 수정
순서:
1. 수정할 페이지에 가서 글 데이터를 불러온다
2. 수정된 글을 프론트엔드 페이지에서 유저에게 받는다.
3. 받는 내용은 sql에 저장한 후 수정된 내용을 화면에 띄운다.

함수밖, 함수 안 중요한 이유
변수의 범위는 함수 안에서 끝나므로 const 변수는 함수 밖에서 재선언 가능하다 범위가 끝나니까

생성, 조회, 수정, 삭제 기능구현